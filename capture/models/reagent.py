import logging
import pandas as pd
import os
import re

import gspread
from capture.googleapi import googleio
from oauth2client.service_account import ServiceAccountCredentials

from utils.data_handling import get_used_reagent_nums

modlog = logging.getLogger('capture.reagentmodels')

def build_reagentdf(reagsheetid, reagsheetworkbook, debug_bool):
    """Read the reagents workbook from Google Drive and return a pandas DataFrame

    :param reagsheetid:        TODO this is a workbook (and unused)
    :param reagsheetworkbook:  TODO this is a sheet
    :param debug_bool: CLI debug boolean
    :return reagdf: pandas DF representation of the reagent worksheet
    """

    if not os.path.exists('reagentdf.csv'): 
        print('Obtaining reagent information from Google Drive... \n', end='')
        modlog.info('Obtaining reagent information from Google Drive...')

        scope = ['https://spreadsheets.google.com/feeds']
        credentials = ServiceAccountCredentials.from_json_keyfile_name('creds.json', scope) 
        gc = gspread.authorize(credentials)

        # open sheet, or book? todo notice the inconsistencies in nomenclature here
        ReagentBook = gc.open_by_key(reagsheetid)
        reagentsheet = ReagentBook.get_worksheet(reagsheetworkbook)
        reagent_list = reagentsheet.get_all_values()

        # Parse sheet to df
        reagdf = pd.DataFrame(reagent_list, columns=reagent_list[0])
        reagdf = reagdf.iloc[1:]
        reagdf = reagdf.reset_index(drop=True)
        reagdf = reagdf.set_index('UUID')
        if debug_bool > 0:
            reagdf.to_csv('reagentdf.csv')
    else:
        print('Obtaining reagent information from local copy... \n', end='')
        modlog.info('Obtaining reagent information from local copy...')
        reagdf = pd.read_csv('reagentdf.csv')
        reagdf = reagdf.set_index('UUID')
        reagdf.fillna(value='null', inplace=True)
    return reagdf

def calc_conc_v1(one_reagent_df, reagent_name):
    """ calculate concentration of each chemical in reagent, return dataframe of chemicals and concentrations

    very similar to ESCALATEreport version of this fuction.  Slightly modified return format
    uses the logic included in the SolUD vs. SolV paper (TODO: insert citation when published)

    :param one_reagent_df: dataframe as generated by concCalc (example below of reagent input)
                                  name                     InChiKey  density   m_type molecularmass amount        unit
        0                Lead Diiodide  RQQRAHKHDFPBMC-UHFFFAOYSA-L     6.16    inorg        461.01   5.12        gram
        1  Di-isopropylammonium iodide  PBGZCCFVBVEIAS-UHFFFAOYSA-N  1.45427      org         229.1   1.22        gram
        2          Gamma-Butyrolactone  YEJRWHAVMIAJKC-UHFFFAOYSA-N     1.12  solvent         86.09     11  milliliter
        3                         null                         null     null     null          null   null        null
    :param reagent_name: parsed name of the reagent (ex. '_raw_reagent_1')

    :return: dictionary with keys formatted as ex. {'reagent': 'Reagent2', 'chemical_list': ['PbI2', 'PyrrolidiniumIodide', 'DMSO'], 'item1_formulaconc': 1.55, 'item2_formulaconc': 1.93}
    """
    conc = {}
    # calculate the total volume of the reagent solution using the volume of the chemicals as an approximation
    for index, row in one_reagent_df.iterrows():
        if row['unit'] == 'gram':
            one_reagent_df.at[index, 'chemical_volume'] = float(row['amount']) / \
                                                          float(row['density'])  # converts grams to mL
        elif row['unit'] == 'milliliter':
            one_reagent_df.at[index, 'chemical_volume'] = row['amount']  # leaves mL well enough alone
        elif row['unit'] == 'null':
            one_reagent_df.at[index, 'chemical_volume'] = 0  # null is null!

    # calculate the concentrations of each chemical using the approximated volume from above
    final_reagent_volume = one_reagent_df['chemical_volume'].astype(float).sum()
    chemical_list = []
    for index, row in one_reagent_df.iterrows():
        index_name = int(index)+1
        if row['unit'] == 'gram':
            calculated_concentration = float(row['amount']) / float(row['molecularmass']) / \
                                             float(final_reagent_volume / 1000)  # g --> mol --> [M] (v1-conc)
            chemical_list.append(one_reagent_df.loc[(index, 'name')])
            conc[f'item{index_name}_formulaconc'] = calculated_concentration
        elif row['unit'] == 'milliliter':
            calculated_concentration = float(row['amount']) * float(row['density']) / \
                                        float(row['molecularmass']) / float(final_reagent_volume / 1000)
            chemical_list.append(one_reagent_df.loc[(index, 'name')])
            conc[f'item{index_name}_formulaconc'] = calculated_concentration
        elif row['unit'] == 'null':
            pass

    conc['chemical_list'] = chemical_list
    conc['reagent'] = reagent_name
    return(conc)

def parse_reagent_to_df(reagentid, reagentdf, chemdf):
    ''' Build dataframe of 'name', 'amounts' and 'units'

    :param reagentid: specification interface ID provide by the user in the xlsx frontend 
    :param reagentdf: reagent_object sheet downloaded from gdrive and indexed on UUID
    :param chemdf: chemical inventory downloaded from gdrive and indexed on UUID

    :returns:  pandas dataframe of the following general structure

                              name                     InChiKey  density   m_type molecularmass amount        unit
    0                Lead Diiodide  RQQRAHKHDFPBMC-UHFFFAOYSA-L     6.16    inorg        461.01   5.12        gram
    1  Di-isopropylammonium iodide  PBGZCCFVBVEIAS-UHFFFAOYSA-N  1.45427      org         229.1   1.22        gram
    2          Gamma-Butyrolactone  YEJRWHAVMIAJKC-UHFFFAOYSA-N     1.12  solvent         86.09     11  milliliter
    3                         null                         null     null     null          null   null        null
    '''
    one_reagent_df = pd.DataFrame()
    for columnheader in reagentdf.columns:
        chemical_number = columnheader.split('_')[1]

        if "chemical_" in columnheader and "name" in columnheader:
            chemical_name = reagentdf.loc["%s" %reagentid, columnheader]
            one_reagent_df.loc['name', chemical_number] = chemical_name
            if chemical_name == 'null' or chemical_name == '0' or chemical_name == 0:
                one_reagent_df.loc['molecularmass', chemical_number] = 'null'
                one_reagent_df.loc['density', chemical_number] = 'null'
            else:
                one_reagent_df.loc['molecularmass', chemical_number] = chemdf.loc["%s" %chemical_name, 'Molecular Weight (g/mol)']
                one_reagent_df.loc['density', chemical_number] = chemdf.loc["%s" %chemical_name, 'Density            (g/mL)',]

        if 'chemicals_' in columnheader and 'InChIKey' in columnheader:
            one_reagent_df.loc['InChiKey', chemical_number] = reagentdf.loc["%s" %reagentid, columnheader]

        if 'chemicals_' in columnheader and 'actual_amount' in columnheader and not "units" in columnheader:
            value = reagentdf.loc["%s" %reagentid, columnheader]
            if value == 'null' or value == '0' or value == 0:
                one_reagent_df.loc['amount', chemical_number] = 'null'
            one_reagent_df.loc['amount', chemical_number] = value

        if 'chemicals_' in columnheader and 'amount_units' in columnheader:
            value = reagentdf.loc["%s" %reagentid, columnheader]
            if value == 'null' or value == '0' or value == 0:
                one_reagent_df.loc['amount', chemical_number] = 'null'
            one_reagent_df.loc['unit', chemical_number] = value

    one_reagent_df = one_reagent_df.transpose()
    return one_reagent_df

def buildreagents(rxndict, chemdf, reagentdf, solventlist):
    """Return rdict, old_reagents, two dicts each  mapping from reagent IDs to perovskitereagent objects

    Checks that reagents were only specified in one manner in the Template: 'list-style' or with a ModelID
     Old reagents are used for multi-stock sampling.
    """
    modlog = logging.getLogger('capture.models.reagent.buildreagents')
    reagentdict = {}
    old_reagents = {}

    used_reagent_nums = get_used_reagent_nums(rxndict)
    for interface_item in rxndict:
        # parse 'list-style' reagent specifications from Template
        if 'Reagent' in interface_item and "chemical_list" in interface_item:
            item_is_reagent = True
            reagentname = interface_item.split('_')[0]
            ## ensure that the reagent definition is not being defined in two different ways
            idflag = reagentname + "_ID"
            if idflag in rxndict:
                modlog.error('Too many specifications of %s. Overspecified reagent cannot proceed.  Exiting.' % reagentname)
                print('Too many specifications of %s. Overspecified reagent cannot proceed.  Exiting.' % reagentname)
            else:
                entry_num = reagentname.split('t')[1]
                reagentvariables = {}
                reagentvariables['reagent'] = reagentname

                for variable, value in rxndict.items():
                    #if reagentname in variable and '(ul)' not in variable:
                    if re.search(f"^{reagentname}", variable) and '(ul)' not in variable:
                        variable = variable.split('_', 1)
                        reagentvariables[variable[1]] = value

                reagent = perovskitereagent(reagentvariables,
                                            rxndict,
                                            entry_num,
                                            chemdf,
                                            solventlist)
                if 'Old' in interface_item:
                    old_reagents[entry_num] = reagent
                else:
                    reagentdict[entry_num] = reagent

        #parse specifications from reagent model ID
        elif "Reagent" in interface_item and "_ID" in interface_item:
            reagentvariables = {}

            reagentname = interface_item.split('_')[0] #form ex 'reagen1' 
            entry_num = reagentname.split('t')[1] #for ex. '1'

            if int(entry_num) not in used_reagent_nums:
                continue

            reagentid = rxndict[interface_item]
            one_reagent_df = parse_reagent_to_df(reagentid, reagentdf, chemdf)
            reagentvariables = calc_conc_v1(one_reagent_df, reagentname)

            reagent = perovskitereagent(reagentvariables,
                                        rxndict,
                                        entry_num,
                                        chemdf,
                                        solventlist)

            reagentdict[entry_num] = reagent

            if 'Old' in interface_item:
                old_reagents[entry_num] = reagent
            else:
                reagentdict[entry_num] = reagent

    for k, v in reagentdict.items():
        modlog.info("%s : %s" %(k,vars(v)))
    
    return reagentdict, old_reagents

class perovskitereagent:
    """Reaction class containing user specified and calculated variables
    

    :param reactantinfo:  input dictionary describing the structure of the reagent in terms of concentration.  
                ex. structure: {'reagent': 'Reagent2', 'chemical_list': ['PbI2', 'PyrrolidiniumIodide', 'DMSO'], 'item1_formulaconc': 1.55, 'item2_formulaconc': 1.93}
    :param rxndict: dictionary of specification interface inputs
    :param reagentnumber: numerical integer value of reagent
    :
    :return: users' reagents specification which containing attributes all of the properties including prep info and concentrations
    """
    def __init__(self, reactantinfo, rxndict, reagentnumber, chemdf, solvent_list):
        self.name = reagentnumber # reag1, reag2, etc
        self.chemicals = reactantinfo['chemical_list'] # list of the chemicals in this reagent

        # {item<i>_formulaconc: concentration for all chemical item indices i in self}
        self.concs = self.concentrations(reactantinfo, chemdf, rxndict)
        self.ispurebool = self.ispure()
        self.solventnum = self.solvent(solvent_list)  # todo bad name is bad, this should be solventindex  
        self.solvent_list = solvent_list

        #passes the reaction preparation step if a pure chemical 
        if len(self.chemicals) > 1:
            self.preptemperature = self.preptemp(reactantinfo, rxndict)
            self.prepstirrate = self.prepstir(reactantinfo, rxndict)
            self.prepduration = self.prepdur(reactantinfo, rxndict)
        else:
            self.preptemperature = "null"
            self.prepstirrate = "null"
            self.prepduration = "null"
        self.prerxntemp = self.prerxn(reactantinfo, rxndict)
        self.preptempunits = "celsius"
        self.prepstirunits = "rpm"
        self.prepdurunits = "seconds"

    @property
    def component_dict(self):
        """
        :return: a dict mapping: chemical_names => concentrations
        """
        out = {}
        for item_i, conc in self.concs.items():
            i = int(item_i[-1]) - 1  # zero index the chemical names
            chemical_name = self.chemicals[i]
            if chemical_name not in self.solvent_list:
                out[chemical_name] = conc

        return out

    #checks for user specified values, if none, returns default
    def prerxn(self, reactantinfo, rxndict):
        try:
            self.prerxntemp = reactantinfo['prerxn_temperature']
        except Exception:
            self.prerxntemp = rxndict['reagents_prerxn_temperature']
        return(self.prerxntemp)

    def preptemp(self, reactantinfo, rxndict):
        try:
            self.preptemperature = reactantinfo['prep_temperature']
        except Exception:
            self.preptemperature = rxndict['reagents_prep_temperature']
        return(self.preptemperature)

    #checks for user specified values, if none, returns default 
    def prepstir(self, reactantinfo, rxndict):
        try:
            self.prepstirrate = reactantinfo['prep_stirrate']
        except:
            self.prepstirrate = rxndict['reagents_prep_stirrate']
        return(self.prepstirrate)

    def prepdur(self, reactantinfo, rxndict):
        try:
            self.prepduration = reactantinfo['prep_duration']
        except:
            self.prepduration = rxndict['reagents_prep_duration']
        return(self.prepduration)
    
    def solvent(self, solventlist):
        if len(self.chemicals) > 1:
            ## automated solvent detection could go here
            solventnum = self.chemicals[-1:][0]
        else: 
            solventnum = 0
        return(solventnum)

    def ispure(self):
        modlog = logging.getLogger('capture.perovskitereagent.ispure')
        if len(self.chemicals) == 1:
            return(1)
        elif len(self.chemicals) > 1:
            return(0)
        else:
            modlog.Error("Reagents are improperly constructed!")

    def concentrations(self, reactantinfo, chemdf, rxndict):
        """Return a dict mapping {item<i>_formulaconc: concentration for all chemical item indices i in self}
        :param reactantinfo:
        :param chemdf:
        :param rxndict:
        :return:
        """
        concdict = {}
        chemicalitem = 1
        for chemical in self.chemicals:
            # todo talk to ian about this:
            # this name seems like it doesnt ever exist in the spreadsheet
            # and so the listcomp below will always evaluate to the empty list
            variablename = 'item%s_formulaconc' %chemical
            updatedname = 'conc_chem%s' %chemical
#            for key, value in reactantinfo.items():
#                if 'chemical' in key:
#                    if variablename in key:
#                        concdict[updatedname] = value
#                print(concdict)
            if len(self.chemicals) == 1:
                itemlabel = 'conc_item1' 
                if [key for key in reactantinfo.keys() if variablename in key] == []:
                        #density / molecular weight function returns mol / L of the chemical
                        try:
                            concdict[itemlabel] = (float(chemdf.loc[self.chemicals[0],"Density            (g/mL)"])/ \
                                                   float(chemdf.loc[self.chemicals[0],"Molecular Weight (g/mol)"]) * 1000)
                        except:
                            pass
            else:
                try:
                    itemlabel = 'conc_item%s' %chemicalitem 
                    itemname = 'item%s_formulaconc' %chemicalitem
                    if reactantinfo[itemname] == 'null':
                        pass
                    else:
                        concdict[itemlabel] = float(reactantinfo[itemname])
                    chemicalitem+=1
                except Exception:
                    pass
        return(concdict)
